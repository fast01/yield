# Copyright (c) 2011 Minor Gordon
# All rights reserved

# This source file is part of the Yield project.

# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
# * Redistributions of source code must retain the above copyright
# notice, this list of conditions and the following disclaimer.
# * Redistributions in binary form must reproduce the above copyright
# notice, this list of conditions and the following disclaimer in the
# documentation and/or other materials provided with the distribution.
# * Neither the name of the Yield project nor the
# names of its contributors may be used to endorse or promote products
# derived from this software without specific prior written permission.

# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL Minor Gordon BE LIABLE FOR ANY DIRECT,
# INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
# THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

assert __name__ == "__main__"

from copy import copy, deepcopy
from os import chdir, getcwd, listdir, makedirs, stat, unlink
from os.path import abspath, \
                    dirname, \
                    exists, \
                    isdir, \
                    isfile, \
                    join as path_join, \
                    sep as path_sep, \
                    split as path_split, \
                    splitext
from optparse import OptionParser
import re
import subprocess
import sys
import traceback

from yuild import Makefile, TopLevelMakefile, \
                  SourceFiles, \
                  VCXProj, VCXProjFilters, VCXProjUser, VCXSln
from yuild.constant import C_CXX_INCLUDE_FILE_FNMATCH_PATTERNS, \
                           C_CXX_FILE_FNMATCH_PATTERNS, \
                           CXX_SOURCE_FILE_FNMATCH_PATTERNS, \
                           INCLUDE_FILE_FNMATCH_PATTERNS, \
                           INDENT_SPACES, \
                           PLATFORMS, \
                           PLATFORM_GUARDS, \
                           SOURCE_FILE_FNMATCH_PATTERNS
from yutil import copy_file, \
                  deduplist, \
                  fnmatch, \
                  indent, \
                  list_subdirectories, \
                  mirror_subdirectories, \
                  rglob, \
                  write_file


# Constants
ROOT_DIR_PATH = dirname(__file__)
INCLUDE_DIR_PATH = path_join(ROOT_DIR_PATH, "include")
SRC_DIR_PATH = path_join(ROOT_DIR_PATH, "src")
TEST_DIR_PATH = path_join(ROOT_DIR_PATH, "test")


PROJECT_REFERENCES = {
    "yield": tuple(),
    "yield.aio": ("yield",),
    "yield.fs": ("yield.i18n",),
    "yield.fs.aio": ("yield.aio", "yield.fs", "yield.thread"),
    "yield.http": ("yield.uri",),
    "yield.http.client": ("yield.http", "yield.sockets.client"),
    "yield.http.server": ("yield.fs", "yield.http", "yield.sockets.server"),
    "yield.i18n": ("yield",),
    "yield.poll": ("yield",),
    "yield.process": ("yield.fs",),
    "yield.sockets": ("yield",),
    "yield.sockets.aio": ("yield.aio", "yield.sockets.poll"),
    "yield.sockets.client": ("yield.sockets.aio", "yield.stage"),
    "yield.sockets.poll": ("yield.poll", "yield.sockets"),
    "yield.sockets.server": ("yield.sockets.aio", "yield.stage"),
    "yield.sockets.ssl": ("yield.sockets",),
    "yield.stage": ("yield.thread",),
    "yield.thread": ("yield",),
    "yield.uri": ("yield",),
}

PROJECT_NAMES = PROJECT_REFERENCES.keys()

AUTHOR = "Minor Gordon"

#AUTOCONF = {
#    "sockets.ssl": {
#    #    "unix": { "YIELD_HAVE_OPENSSL": ( "crypto", "ssl", "ssl.h" ), },
#    #    "win32": { "YIELD_HAVE_OPENSSL": ( "libeay32", "ssleay32", "ssl.h" ), },
#    },
#
#    "thread": {
#    #    "unix": { "YIELD_HAVE_PAPI": ( "papi", "papi.h" ), },
#    },
#
##    "unix": { "YIELD_HAVE_ZLIB": ( "z", "zlib.h" ), },
##    "win32":  { "YIELD_HAVE_ZLIB": ( "zdll", "zlib.h" ), },    
#
#    "uuid": {
#        #    "linux": { "YIELD_HAVE_LINUX_LIBUUID": ( "uuid", "uuid/uuid.h" ), },
#    },
#}
#for project_name in AUTOCONF.iterkeys():
#    assert project_name in PROJECT_NAMES, project_name


CXXFLAGS = {
    "unix": ["-fno-rtti", "-Wall", "-Wold-style-cast", "-Wunused-macros"],
    "win32": [
      "/EHsc", # Enable exceptions
      "/GR-", # Disable RTTI
      "/MP", # Multiprocess compilation
      "/nologo",
      "/wd\"4100\"",
      "/wd\"4127\"",
      "/wd\"4290\"",
      "/wd\"4355\"",
      "/wd\"4512\"",
      # "/Za" # Disable language extensions
    ]
}
for platform in CXXFLAGS.iterkeys():
    assert platform in PLATFORMS, platform

CXXPATH = {
    "*": [
        INCLUDE_DIR_PATH,
    ]
}
for platform in CXXPATH.iterkeys():
    assert platform in PLATFORMS, platform

LDFLAGS = {
    "win32": [
        "/ignore:4006",
        "/ignore:4221"
    ],
}
for platform in LDFLAGS.iterkeys():
    assert platform in PLATFORMS, platform


LIBPATH = {
    "*": [path_join(ROOT_DIR_PATH, "lib", "yield")],
    # "win32": [path_join( ROOT_DIR_PATH, "lib", "win32" )]
}
for platform in LIBPATH.iterkeys():
    assert platform in PLATFORMS, platform


LIBS = {
    "yield": {
        "linux": ["rt", "stdc++"],
        "sunos": ["m", "rt", "stdc++"],
    },

    "yield.fs.aio": {
        "linux": ["aio"],
    },

    "yield.i18n": {
        "darwin": ["iconv"],
        "freebsd": ["iconv", "intl"],
        "sunos": ["iconv"],
    },

    "yield.sockets": {
        "sunos": ["nsl", "socket"],
    },

    "yield.process": {
        "linux": ["dl"],
    },

    "yield.thread": {
        "freebsd": ["pthread"],
        "linux": ["pthread"],
        "sunos": ["cpc", "kstat"],
    },

#    "yield.uuid": {
#        "sunos": ["uuid"],
#    },
}
for project_name in LIBS.iterkeys():
    assert project_name in PROJECT_NAMES, project_names

OUTPUT_FILE_PATHS = {}
for project_name in PROJECT_NAMES:
    OUTPUT_FILE_PATHS[project_name] = \
        path_join(ROOT_DIR_PATH, "lib", "yield", '_'.join(project_name.split('.')))
    OUTPUT_FILE_PATHS[project_name + "_test"] = \
        path_join(ROOT_DIR_PATH, "bin", "yield", '_'.join(project_name.split('.')) + "_test")

PROJECT_DIR_PATHS = {}
for project_name in PROJECT_NAMES:
    project_dir_path = path_join(ROOT_DIR_PATH, "proj", path_sep.join(project_name.split('.')))
    PROJECT_DIR_PATHS[project_name] = project_dir_path
    PROJECT_DIR_PATHS[project_name + "_test"] = project_dir_path

for project_name in PROJECT_NAMES:
    PROJECT_REFERENCES[project_name + "_test"] = [project_name]
    if project_name == "yield.http.client":
        PROJECT_REFERENCES[project_name + "_test"].append("yield.http.server")

# Expand project references so that the list has dependencies going left -> right, e.g.
# if project A depends on project B depends on project C, the order will be [A, B, C]
def __expand_project_references(project_name):
    project_references = []
    for project_reference in PROJECT_REFERENCES[project_name]:
        project_references.append(project_reference)
        for project_reference in __expand_project_references(project_reference):
            try:
                del project_references[project_references.index(project_reference)]
            except ValueError:
                pass
            project_references.append(project_reference)
    return project_references
PROJECT_REFERENCES_EXPANDED = {}
for project_name in PROJECT_REFERENCES.iterkeys():
    PROJECT_REFERENCES_EXPANDED[project_name] = \
        deduplist(__expand_project_references(project_name))


LIBS_EXPANDED = {}
for project_name, project_references in PROJECT_REFERENCES_EXPANDED.iteritems():
    # Add all of the project references' libs to the project's libs
    LIBS_EXPANDED[project_name] = {}
    for project_reference in project_references + [project_name]:
        try:
            for platform, platform_libs in LIBS[project_reference].iteritems():
                LIBS_EXPANDED[project_name].setdefault(platform, []).extend(platform_libs)
        except KeyError:
            pass

    # Add the project references' outputs to the project's libs
    for project_reference in project_references:
        project_reference_lib = path_split(OUTPUT_FILE_PATHS[project_reference])[-1]
        LIBS_EXPANDED[project_name].setdefault('*', [])
        assert project_reference_lib not in LIBS_EXPANDED[project_name]['*'], LIBS_EXPANDED[project_name]['*']
        LIBS_EXPANDED[project_name]['*'].append(project_reference_lib)

    # dedup
    for platform in LIBS_EXPANDED[project_name].iterkeys():
        LIBS_EXPANDED[project_name][platform] = deduplist(LIBS_EXPANDED[project_name][platform])
LIBS = LIBS_EXPANDED


#EXCLUDE_FILE_PATHS = {}
INCLUDE_FILE_PATHS = {}
SOURCE_FILE_PATHS = {}

for project_name in PROJECT_NAMES:
    project_include_dir_path = path_join(INCLUDE_DIR_PATH, path_sep.join(project_name.split('.')))
    project_source_dir_path = path_join(SRC_DIR_PATH, path_sep.join(project_name.split('.')))
    project_test_dir_path = path_join(TEST_DIR_PATH, path_sep.join(project_name.split('.')))

    INCLUDE_FILE_PATHS[project_name] = [
        path_join(project_include_dir_path, fnmatch_pattern)
        for fnmatch_pattern in INCLUDE_FILE_FNMATCH_PATTERNS
    ]

    for platform in PLATFORMS:
        if exists(path_join(project_include_dir_path, platform)):
            INCLUDE_FILE_PATHS[project_name].extend([
                path_join(project_include_dir_path, platform, fnmatch_pattern)
                for fnmatch_pattern in INCLUDE_FILE_FNMATCH_PATTERNS
            ])

    INCLUDE_FILE_PATHS[project_name + "_test"] = []

    SOURCE_FILE_PATHS[project_name] = [
         path_join(project_source_dir_path, fnmatch_pattern)
         for fnmatch_pattern in INCLUDE_FILE_FNMATCH_PATTERNS + \
                                SOURCE_FILE_FNMATCH_PATTERNS
    ]

    for platform in PLATFORMS:
        if exists(path_join(project_source_dir_path, platform)):
            SOURCE_FILE_PATHS[project_name].extend([
                path_join(project_source_dir_path, platform, fnmatch_pattern)
                for fnmatch_pattern in INCLUDE_FILE_FNMATCH_PATTERNS + \
                                       SOURCE_FILE_FNMATCH_PATTERNS
            ])

    SOURCE_FILE_PATHS[project_name + "_test"] = [
        path_join(project_test_dir_path, fnmatch_pattern)
        for fnmatch_pattern in INCLUDE_FILE_FNMATCH_PATTERNS + \
                               SOURCE_FILE_FNMATCH_PATTERNS
    ]

    for platform in PLATFORMS:
        if exists(path_join(project_test_dir_path, platform)):
            SOURCE_FILE_PATHS[project_name + "_test"].extend([
                path_join(project_test_dir_path, platform, fnmatch_pattern)
                for fnmatch_pattern in INCLUDE_FILE_FNMATCH_PATTERNS + \
                                       SOURCE_FILE_FNMATCH_PATTERNS
            ])

    #EXCLUDE_FILE_PATHS[project_name] = [] # SOURCE_FILE_PATHS[project_name + "_test"]
    #EXCLUDE_FILE_PATHS[project_name + "_test"] = []

INCLUDE_FILE_PATHS["yield"] = [
    path_join(INCLUDE_DIR_PATH, "yield", "types.hpp"), # before atomic
    path_join(INCLUDE_DIR_PATH, "yield", "atomic.hpp"), # before object
    path_join(INCLUDE_DIR_PATH, "yield", "object.hpp"), # before event
    path_join(INCLUDE_DIR_PATH, "yield", "event.hpp"), # before message
    path_join(INCLUDE_DIR_PATH, "yield", "message.hpp"), # before response
    path_join(INCLUDE_DIR_PATH, "yield", "response.hpp"), # before exception
    path_join(INCLUDE_DIR_PATH, "yield", "time.hpp"), # before event_queue
] + \
INCLUDE_FILE_PATHS["yield"]

INCLUDE_FILE_PATHS["yield_test"] = [path_join(INCLUDE_DIR_PATH, "yunit.hpp")]

INCLUDE_FILE_PATHS["yield.aio"] = [
    path_join(INCLUDE_DIR_PATH, "yield", "aio", "posix", "aiocb.hpp"),
    path_join(INCLUDE_DIR_PATH, "yield", "aio", "win32", "aiocb.hpp"),
    path_join(INCLUDE_DIR_PATH, "yield", "aio", "aiocb.hpp"),
    path_join(INCLUDE_DIR_PATH, "yield", "aio", "sockets", "aiocb.hpp"), # before accept_aiocb
] + INCLUDE_FILE_PATHS["yield.aio"]

INCLUDE_FILE_PATHS["yield.fs"] = [
    path_join(INCLUDE_DIR_PATH, "yield", "fs", "path.hpp"),
    path_join(INCLUDE_DIR_PATH, "yield", "fs", "posix", "directory.hpp"),
    path_join(INCLUDE_DIR_PATH, "yield", "fs", "posix", "file.hpp"),
    path_join(INCLUDE_DIR_PATH, "yield", "fs", "posix", "file_system.hpp"),
    path_join(INCLUDE_DIR_PATH, "yield", "fs", "win32", "stat.hpp"),
    path_join(INCLUDE_DIR_PATH, "yield", "fs", "win32", "directory.hpp"),
    path_join(INCLUDE_DIR_PATH, "yield", "fs", "win32", "file.hpp"),
    path_join(INCLUDE_DIR_PATH, "yield", "fs", "win32", "file_system.hpp"),
    path_join(INCLUDE_DIR_PATH, "yield", "fs", "file.hpp"), # before aiocb
    path_join(INCLUDE_DIR_PATH, "yield", "fs", "stat.hpp"), # before directory
] + \
INCLUDE_FILE_PATHS["yield.fs"]

INCLUDE_FILE_PATHS["yield.i18n"] = [
    path_join(INCLUDE_DIR_PATH, "yield", "i18n", "posix", "code.hpp"),
    path_join(INCLUDE_DIR_PATH, "yield", "i18n", "posix", "iconv.hpp"),
    path_join(INCLUDE_DIR_PATH, "yield", "i18n", "posix", "tstring.hpp"),
    path_join(INCLUDE_DIR_PATH, "yield", "i18n", "win32", "code.hpp"),
    path_join(INCLUDE_DIR_PATH, "yield", "i18n", "win32", "iconv.hpp"),
    path_join(INCLUDE_DIR_PATH, "yield", "i18n", "win32", "tstring.hpp"),
] + \
INCLUDE_FILE_PATHS["yield.i18n"]

INCLUDE_FILE_PATHS["yield.sockets"] = [
    path_join(INCLUDE_DIR_PATH, "yield", "sockets", "socket.hpp"), # before datagram_socket
] + \
INCLUDE_FILE_PATHS["yield.sockets"]

INCLUDE_FILE_PATHS["yield.sockets.aio"] = [
    path_join(INCLUDE_DIR_PATH, "yield", "sockets", "aio", "aiocb.hpp"), # before accept_aiocb
    path_join(INCLUDE_DIR_PATH, "yield", "sockets", "aio", "win32", "aio_queue.hpp"), # before aio_queue
] + \
INCLUDE_FILE_PATHS["yield.sockets.aio"]

INCLUDE_FILE_PATHS["yield.sockets.client"] = [
    path_join(INCLUDE_DIR_PATH, "yield", "sockets", "peer", "socket_peer.hpp"),
    path_join(INCLUDE_DIR_PATH, "yield", "sockets", "peer", "stream_socket_peer.hpp"),
] + \
INCLUDE_FILE_PATHS["yield.sockets.client"]

INCLUDE_FILE_PATHS["yield.sockets.server"] = [
    path_join(INCLUDE_DIR_PATH, "yield", "sockets", "peer", "socket_peer.hpp"),
    path_join(INCLUDE_DIR_PATH, "yield", "sockets", "peer", "stream_socket_peer.hpp"),
] + \
INCLUDE_FILE_PATHS["yield.sockets.server"]

INCLUDE_FILE_PATHS["yield.stage"] = [
    path_join(INCLUDE_DIR_PATH, "yield", "stage", "event.hpp"),
    path_join(INCLUDE_DIR_PATH, "yield", "stage", "message.hpp"),
    path_join(INCLUDE_DIR_PATH, "yield", "stage", "response.hpp"),
    path_join(INCLUDE_DIR_PATH, "yield", "stage", "stage_scheduler.hpp"),
] + \
INCLUDE_FILE_PATHS["yield.stage"]

INCLUDE_FILE_PATHS["yield.thread"] = [
    path_join(INCLUDE_DIR_PATH, "yield", "thread", "mutex.hpp"),
    path_join(INCLUDE_DIR_PATH, "yield", "thread", "condition_variable.hpp"), # before synchronized_queue
    path_join(INCLUDE_DIR_PATH, "yield", "thread", "synchronized_queue.hpp"), # Before synchronized_event_queue
    path_join(INCLUDE_DIR_PATH, "yield", "thread", "thread.hpp"),
] + \
INCLUDE_FILE_PATHS["yield.thread"]

SOURCE_FILE_PATHS["yield.fs"] = [
    path_join(SRC_DIR_PATH, "yield", "fs", "win32", "stat.hpp"), # before directory
] + \
SOURCE_FILE_PATHS["yield.fs"]

SOURCE_FILE_PATHS["yield.thread"] = [
    path_join(SRC_DIR_PATH, "yield", "thread", "win32", "mutex.hpp"), # before condition_variable
    path_join(SRC_DIR_PATH, "yield", "thread", "win32", "lightweight_mutex.hpp"), # before condition_variable
    path_join(SRC_DIR_PATH, "yield", "thread", "win32", "semaphore.hpp"), # before condition_variable
] + \
SOURCE_FILE_PATHS["yield.thread"]

for project_name in INCLUDE_FILE_PATHS.iterkeys():
    for file_paths in (INCLUDE_FILE_PATHS, SOURCE_FILE_PATHS):
        file_paths[project_name] = \
            deduplist(list(rglob(file_paths[project_name])))

THIRD_PARTY_SOURCE_FNMATCH_PATTERNS = (
    "charProps.c",
    "genx.*",
    "pyparsing.py",
    "rapidxml.hpp",
    "SimpleOpt.h",
    "yajl.*",
)




# Parse options
option_parser = OptionParser()
option_parser.add_option("--check-src-namespace", action="store_true")
option_parser.add_option("--check-src-type-id", action="store_true")
option_parser.add_option("--check-src-width", action="store_true")
option_parser.add_option("--check-src-yunit", action="store_true")
option_parser.add_option("-f", "--force", action="store_true")
option_parser.add_option("--format-src", action="store_true")
option_parser.add_option("-p", "--project", action="append", dest="project_names")
option_parser.add_option("--generate-dist", action="store_true")
option_parser.add_option("--generate-proj", action="store_true")
option_parser.add_option("--generate-src", action="store_true")
option_parser.add_option("--generate-src-rl", action="store_true")
option_parser.add_option("--generate-test", action="store_true")
option_parser.add_option("--generate-test_main_cpp", action="store_true")
option_parser.add_option("--generate-test_py", action="store_true")

options, _ = option_parser.parse_args()

if options.project_names is not None and len(options.project_names) > 0:
    for project_name in options.project_names:
        assert project_name in PROJECT_NAMES, project_name
else:
    options.project_names = PROJECT_NAMES


if options.check_src_namespace or \
   options.check_src_type_id or \
   options.check_src_width or \
   options.check_src_yunit:

    include_file_paths = []
    source_file_paths = []
    for project_name in options.project_names:
        for include_file_paths_ in INCLUDE_FILE_PATHS[project_name]:
            include_file_paths.extend(list(rglob(include_file_paths_)))
        for source_file_paths_ in SOURCE_FILE_PATHS[project_name]:
            source_file_paths.extend(list(rglob(source_file_paths_)))

    if options.check_src_namespace or options.check_src_type_id:
        for include_file_path in include_file_paths:
            namespaces = include_file_path[len(INCLUDE_DIR_PATH) + 1:].split(path_sep)[:-1]
            assert len(namespaces) > 0

            include_file_lines = [include_file_line.strip()
                                  for include_file_line in
                                  open(include_file_path).readlines()]

            for include_file_line in include_file_lines:
                if options.check_src_namespace:
                    if include_file_line.startswith("namespace ") and \
                       not '{' in include_file_line:
                        namespace = include_file_line[10:]
                        if namespace == namespaces[0]:
                            del namespaces[0]
                        else:
                            print include_file_path[len(path_join(INCLUDE_DIR_PATH, "yield")) + 1:] + ":",
                            print "expected namespace", namespaces[0],
                            print "but found", namespace
                            break

                if options.check_src_type_id:
                    from zlib import crc32

                    if include_file_line.startswith("class") and \
                       not include_file_line.endswith(';'):
                        globals()["class_"] = include_file_line.split(' ')[1]
                    elif "TYPE_ID = " in include_file_line:
                        type_id = include_file_line.split(' ')[-1][:-1]
                        if type_id.endswith("UL"): type_id = type_id[:-2]
                        type_name = "::".join(namespaces + [class_])
                        expected_type_id = str(crc32(type_name) & 0xffffffff)

                        if type_id != expected_type_id:
                            print type_name + ": expected TYPE_ID =",
                            print expected_type_id, "but found", type_id

                        quoted_type_name = '"' + type_name + '"'
                        found_quoted_type_name = False
                        for other_include_file_line in include_file_lines:
                            if quoted_type_name in other_include_file_line:
                                found_quoted_type_name = True
                                break
                        if not found_quoted_type_name:
                            print type_name + ": could not find type name literal"

    if options.check_src_width:
        for file_path in include_file_paths + source_file_paths:
            if not fnmatch(file_path, THIRD_PARTY_SOURCE_FNMATCH_PATTERNS):
                file_lines = open(file_path).readlines()
                for file_line_i in xrange(len(file_lines)):
                    file_line = file_lines[file_line_i]
                    if len(file_line) > 80:
                        print file_path + ':' + str(file_line_i + 1) + " is " + \
                              str(len(file_line)) + " columns wide"

    if options.check_src_yunit:
        source_files = SourceFiles(source_file_paths)
        source_files = source_files.filter(CXX_SOURCE_FILE_FNMATCH_PATTERNS)
        source_files = source_files.exclude(THIRD_PARTY_SOURCE_FNMATCH_PATTERNS)
        for source_file_path in source_files['*']:
            source_dir_path, source_file_name = path_split(source_file_path)
            source_file_stem, source_file_ext = splitext(source_file_name)
            if not source_file_stem.endswith("_test") and\
               not source_file_stem.endswith("_test_main"):
                test_file_path = \
                    path_join(
                        source_dir_path,
                        source_file_stem + "_test" + source_file_ext
                    )
                if not exists(test_file_path):
                    print "missing", test_file_path[len(YIELD_SRC_ROOT_DIR_PATH) + 1:]


if options.generate_dist:
    PROJECT_BUILD_ORDER = []
    def __fill_project_build_order(project_name):
        for project_reference in PROJECT_REFERENCES[project_name]:
            __fill_project_build_order(project_reference)

        if project_name not in PROJECT_BUILD_ORDER:
            PROJECT_BUILD_ORDER.append(project_name)
    for project_name in options.project_names:
        __fill_project_build_order(project_name)

    ypy_dir_path = path_join(ROOT_DIR_PATH, "..", "ypy")
    if not exists(ypy_dir_path):
        ypy_dir_path = None

    for project_name in options.project_names:
        hpp = []
        cpp = ['#include "%s.hpp"\n\n\n' % '_'.join(project_name.split('.'))]

        for project_reference in PROJECT_BUILD_ORDER[:PROJECT_BUILD_ORDER.index(project_name) + 1]:
            include_files = SourceFiles(INCLUDE_FILE_PATHS[project_reference])
            include_files = include_files.filter(C_CXX_INCLUDE_FILE_FNMATCH_PATTERNS)
            hpp.append(include_files.get_combined_repr())
            source_files = SourceFiles(SOURCE_FILE_PATHS[project_reference])
            source_files = source_files.filter(C_CXX_FILE_FNMATCH_PATTERNS)
            source_files = source_files.exclude("test_*")
            source_files = source_files.exclude("*_test*")
            cpp.append(source_files.get_combined_repr())

        project_dist_dir_path = \
            path_join(ROOT_DIR_PATH, "dist", path_sep.join(project_name.split('.')))
        if not exists(project_dist_dir_path):
            makedirs(project_dist_dir_path)

        for file_ext in ("cpp", "hpp"):
            file_path = \
                path_join(
                    project_dist_dir_path,
                    '_'.join(project_name.split('.')) + '.' + file_ext
                )

            write_file(file_path, locals()[file_ext], force=options.force)

            if ypy_dir_path is not None:
                ypy_file_path = \
                    path_join(
                        ypy_dir_path,
                        "share",
                        "yield",
                        "dist",
                        path_sep.join(project_name.split('.')),
                        path_split(file_path)[1]
                    )

                if exists(ypy_file_path):
                    copy_file(file_path, ypy_file_path)


if options.format_src:
    source_paths = {
        "Yield": (
            path_join(ROOT_DIR_PATH, "include"),
            path_join(ROOT_DIR_PATH, "src", "yield"),
            path_join(ROOT_DIR_PATH, "test", "yield")
        ),
        "yutil": (
            path_join(ROOT_DIR_PATH, "src", "yutil.py"),
            path_join(ROOT_DIR_PATH, "test", "yutil_test.py"),
        ),
        "yuild": (
            path_join(ROOT_DIR_PATH, "src", "yuild"),
            path_join(ROOT_DIR_PATH, "test", "yuild"),
        )
    }

    for project, source_paths in source_paths.iteritems():
        source_files = SourceFiles()
        for source_path in source_paths:
            if isdir(source_path):
                for fnmatch_pattern in INCLUDE_FILE_FNMATCH_PATTERNS + \
                                       SOURCE_FILE_FNMATCH_PATTERNS:
                    for source_file_path in rglob(path_join(source_path, "**", fnmatch_pattern)):
                        source_files.append(source_file_path)
            else:
                assert isfile(source_path), source_path
                source_files.append(source_path)

        source_files = source_files.exclude(THIRD_PARTY_SOURCE_FNMATCH_PATTERNS)

        source_files.format(
            author=AUTHOR,
            force=options.force,
            project=project,
        )


if options.generate_proj:
    for project_name in options.project_names:
        for project_name_suffix, project_type in (("", "lib"), ("_test", "exe")):
            if (project_name == "yield.sockets.client" or project_name == "yield.sockets.server") and\
               project_name_suffix == "_test":
                continue

            project = {
               "build_dir_path": path_join(ROOT_DIR_PATH, "build", path_sep.join(project_name.split('.'))) + project_name_suffix,
               "cxxflags": CXXFLAGS,
               "cxxpath": CXXPATH,
               # "exclude_file_paths": EXCLUDE_FILE_PATHS[project_name + project_name_suffix],
               "include_file_paths": INCLUDE_FILE_PATHS[project_name + project_name_suffix],
               "libpath": LIBPATH,
               "libs": LIBS.get(project_name + project_name_suffix, {}),
               "ldflags": LDFLAGS,
               "name": project_name + project_name_suffix,
               "output_file_path": OUTPUT_FILE_PATHS[project_name + project_name_suffix],
               "project_dir_path": PROJECT_DIR_PATHS[project_name + project_name_suffix],
               "project_references": [
                    path_join(PROJECT_DIR_PATHS[project_reference], project_reference)
                    for project_reference in PROJECT_REFERENCES[project_name + project_name_suffix]
                ],
               "source_dir_path": path_join(SRC_DIR_PATH, path_sep.join(project_name.split('.'))),
               "source_file_paths": SOURCE_FILE_PATHS[project_name + project_name_suffix],
               "type": project_type
            }

            for key in ("build_dir_path", "project_dir_path"):
                if not exists(project[key]):
                    makedirs(project[key])

            if project_name != "yield":
                mirror_subdirectories(
                    project["source_dir_path"],
                    project["build_dir_path"]
                )
            del project["source_dir_path"]

            for project_class, file_ext in (
                (Makefile, ".Makefile"),
                (VCXProj, ".vcxproj"),
                (VCXProjFilters, ".vcxproj.filters"),
                (VCXProjUser, ".vcxproj.user"),
            ):
                write_file(
                    path_join(
                        project["project_dir_path"],
                        project["name"] + file_ext
                    ),
                    str(project_class(**project)),
                    force=options.force
                )

    if len(options.project_names) == len(PROJECT_NAMES):
        # Generate Visual Studio solution
        write_file(
            "yield.sln",
            str(
                VCXSln(
                    [path_join(PROJECT_DIR_PATHS[project_name], project_name)
                     for project_name in PROJECT_NAMES] + \
                    [path_join(PROJECT_DIR_PATHS[project_name], project_name + "_test")
                     for project_name in PROJECT_NAMES
                     if project_name != "yield.sockets.client" and \
                        project_name != "yield.sockets.server"],
                    "yield.sln"
                )
            ),
            newline="\r\n"
        )

        # Generate top-level Makefile
        write_file(
            "Makefile",
            str(TopLevelMakefile(PROJECT_DIR_PATHS, PROJECT_REFERENCES)),
            force=options.force
        )


if options.generate_src or options.generate_src_rl:
    for rl_file_path in rglob(path_join(ROOT_DIR_PATH, "src", "yield", "**", "*.rl")):
        cpp_file_path = \
            path_join(
                dirname(rl_file_path),
                path_split(rl_file_path)[1][:-2] + "cpp"
            )

        if exists(cpp_file_path):
            if options.force or stat(rl_file_path).st_mtime > stat(cpp_file_path).st_mtime:
                args = ["ragel"]
                args.append("-L")
                args.extend(("-o", cpp_file_path))
                args.append(rl_file_path)
                subprocess.call(args)

                SourceFiles(cpp_file_path).format(
                    author=AUTHOR,
                    force=options.force,
                    project="Yield"
                )


if options.generate_test or options.generate_test_main_cpp:
    for project_name in options.project_names:
        project_test_dir_path = None
        test_suite_decls = []
        test_suite_runs = []

        for test_cpp_file in [source_file
            for source_file in SourceFiles(SOURCE_FILE_PATHS[project_name + "_test"])
            if source_file.get_language() == "cpp"]:

            test_cpp_dir_path = dirname(test_cpp_file.get_path())
            if project_test_dir_path is None:
                project_test_dir_path = test_cpp_dir_path
            else:
                assert test_cpp_dir_path.startswith(project_test_dir_path), test_cpp_dir_path + " vs. " + project_test_dir_path

            test_suite_names = []
            test_cpp_file_lines = open(test_cpp_file.get_path()).readlines()
            test_cpp_file_line_i = 0
            while test_cpp_file_line_i < len(test_cpp_file_lines):
                test_cpp_file_line = test_cpp_file_lines[test_cpp_file_line_i].strip()
                if test_cpp_file_line.startswith("TEST_SUITE"):
                    test_suite_declaration = []
                    while test_cpp_file_line_i < len(test_cpp_file_lines):
                        test_cpp_file_line = test_cpp_file_lines[test_cpp_file_line_i].strip()
                        test_suite_declaration.append(test_cpp_file_line)
                        test_cpp_file_line_i += 1
                        if test_cpp_file_line.find(';') != -1:
                            break
                    test_suite_declaration = ''.join(test_suite_declaration).replace(' ', '')
                    test_suite_name = re.match("TEST_SUITE(?:_EX)?\((\w+)", test_suite_declaration)
                    if test_suite_name is not None:
                        test_suite_name = test_suite_name.groups()[0]
                        if not test_suite_name.endswith("TestSuite"):
                            test_suite_name += "TestSuite"
                        test_suite_names.append(test_suite_name)
                else:
                    test_cpp_file_line_i += 1
                    continue

            if len(test_suite_names) > 0:
                test_suite_names = sorted(test_suite_names)

                for test_suite_name in test_suite_names:
                    assert test_suite_name.endswith("TestSuite")
                    test_suite_stem = test_suite_name[:-9]

                    test_suite_decl = \
                        "extern yunit::TestSuite& %(test_suite_name)s();" % locals()

                    test_suite_run = """\
// %(test_suite_stem)s
std::cout << "%(test_suite_stem)s:" << std::endl;
failed_test_case_count += %(test_suite_name)s().run();
std::cout << std::endl;""" % locals()

                    if test_cpp_file.get_platform() != "*":
                        platform_guard = PLATFORM_GUARDS[test_cpp_file.get_platform()]

                        test_suite_decl = indent(INDENT_SPACES["cpp"], test_suite_decl)
                        test_suite_decl = "%(platform_guard)s\n%(test_suite_decl)s\n#endif" % locals()

                        test_suite_run = indent(INDENT_SPACES["cpp"], test_suite_run)
                        test_suite_run = "%(platform_guard)s\n%(test_suite_run)s\n#endif" % locals()

                    test_suite_decls.append(test_suite_decl)
                    test_suite_runs.append(test_suite_run)

        test_suite_decls = '\n'.join(test_suite_decls)
        test_suite_runs = \
            indent(INDENT_SPACES["cpp"], '\n\n'.join(test_suite_runs))

        if project_test_dir_path is not None:
            test_main_cpp_file_path = \
                path_join(project_test_dir_path, '_'.join(project_name.split('.')) + "_test_main.cpp")

            write_file(
                test_main_cpp_file_path,
        """\
#include "yunit.hpp"

#include <iostream>


%(test_suite_decls)s


int main(int, char**) {
  int failed_test_case_count = 0;

%(test_suite_runs)s

  return failed_test_case_count;
}

""" % locals(), force=options.force)

            SourceFiles(test_main_cpp_file_path).format(
                author=AUTHOR,
                force=options.force,
                project="Yield"
            )


if options.generate_test or options.generate_test_py:
    if not '.' in sys.path:
        sys.path.append('.')

    for py_file_path in rglob(path_join(TEST_DIR_PATH, "yield", "**", "*_test.py")):
        try: unlink(splitext(py_file_path)[0] + ".pyc")
        except: pass
        stdoutdata, stderrdata = \
            subprocess.Popen(
                [sys.executable, py_file_path],
                stdout=subprocess.PIPE
            ).communicate()
        if len(stdoutdata) > 0:
            write_file(
                splitext(py_file_path)[0] + ".cpp",
                stdoutdata,
                force=options.force
            )




